import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as r,f as d}from"./app-ud1JXOCg.js";const h={},i=d('<h2 id="cpu-上下文切换" tabindex="-1"><a class="header-anchor" href="#cpu-上下文切换" aria-hidden="true">#</a> CPU 上下文切换</h2><p>即使是单核处理器也支持多线程执行代码，CPU 通过给每个线程分配 CPU 时间片来实现这个机制。时间片是 CPU 分配给各个线程的时间，因为时间片非常短，所以 CPU 通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒 (ms)。</p><p>CPU 通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p><h2 id="volatile" tabindex="-1"><a class="header-anchor" href="#volatile" aria-hidden="true">#</a> volatile</h2><h2 id="synchronized" tabindex="-1"><a class="header-anchor" href="#synchronized" aria-hidden="true">#</a> synchronized</h2><h3 id="锁升级" tabindex="-1"><a class="header-anchor" href="#锁升级" aria-hidden="true">#</a> 锁升级</h3><p>![[Java 对象头的长度.png]]</p><p>![[Mark Word.png]]</p><h4 id="锁升级流程" tabindex="-1"><a class="header-anchor" href="#锁升级流程" aria-hidden="true">#</a> 锁升级流程</h4><p>![[Pasted image 20231014004534.png]]</p><h4 id="无锁" tabindex="-1"><a class="header-anchor" href="#无锁" aria-hidden="true">#</a> 无锁</h4><h4 id="偏向锁" tabindex="-1"><a class="header-anchor" href="#偏向锁" aria-hidden="true">#</a> 偏向锁</h4><p>![[Pasted image 20231014002801.png]]</p><h4 id="轻量级锁" tabindex="-1"><a class="header-anchor" href="#轻量级锁" aria-hidden="true">#</a> 轻量级锁</h4><p>加锁 cas</p><p>![[Pasted image 20231014002959.png]]</p><p>可重入</p><p>![[Pasted image 20231014003011.png]]</p><p>加锁流程</p><p>![[Pasted image 20231014003025.png]]</p><p>解锁流程</p><p>![[Pasted image 20231014003741.png]]</p><p>轻量级解锁时，会使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p><h4 id="重量级锁" tabindex="-1"><a class="header-anchor" href="#重量级锁" aria-hidden="true">#</a> 重量级锁</h4>',24),n=[i];function t(p,s){return e(),r("div",null,n)}const _=a(h,[["render",t],["__file","并发机制底层实现原理.html.vue"]]);export{_ as default};
