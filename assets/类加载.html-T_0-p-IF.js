import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as n,f as e}from"./app-ud1JXOCg.js";const o={},l=e(`<h2 id="jvm-类加载的时机" tabindex="-1"><a class="header-anchor" href="#jvm-类加载的时机" aria-hidden="true">#</a> JVM 类加载的时机</h2><p>在 Java 虚拟机（JVM）中，有多种情况会触发类的加载。类的加载是一个延迟加载的过程，只有在需要访问某个类的信息时才会加载该类。以下是一些触发类加载的情况：</p><ol><li><strong>创建类的实例</strong>：当使用 <code>new</code> 关键字创建一个类的实例对象时，该类会被加载。这包括类的初始化过程。</li><li><strong>访问类的静态成员</strong>：当访问一个类的静态字段（静态变量）或调用一个类的静态方法时，该类会被加载。这也包括类的初始化过程。</li><li><strong>调用 Class.forName() 方法</strong>：通过反射的方式使用 <code>Class.forName(&quot;className&quot;)</code> 方法加载一个类时，该类会被加载。</li><li><strong>调用 ClassLoader.loadClass() 方法</strong>：通过类加载器的 <code>loadClass()</code> 方法来加载一个类时，该类会被加载。</li><li><strong>初始化一个类的子类</strong>：当初始化一个类的子类时，首先会加载并初始化父类。</li><li><strong>使用接口</strong>：在使用接口时，接口定义的常量会被加载。</li><li><strong>使用类的数组</strong>：如果创建一个类的数组，该类会被加载。</li><li><strong>调用 main 方法</strong>：在 Java 应用程序的入口点，即 <code>public static void main(String[] args)</code> 方法中，主类会被加载。</li><li><strong>使用其他特定类</strong>：某些特定的类在加载时可能会引发其他类的加载，例如使用反射或字节码操作库。</li></ol><p>需要注意的是，虽然类在加载时会经历加载、验证、准备、解析和初始化等阶段，但初始化是在真正需要使用类的信息时才会发生，这是 JVM 的延迟初始化策略的一部分，有助于提高性能。</p><h2 id="jvm-类加载的过程" tabindex="-1"><a class="header-anchor" href="#jvm-类加载的过程" aria-hidden="true">#</a> JVM 类加载的过程</h2><ol><li><p>加载（Loading）： 类加载的第一阶段是加载阶段。在加载阶段，JVM 会查找并加载类的字节码文件。这通常是在首次引用类的时候发生，可以通过类加载器（ClassLoader）来完成。加载阶段的目标是获取字节码数据，并创建一个代表类的 Class 对象。</p></li><li><p>验证（Verification）： 在验证阶段，JVM 会对加载的类文件进行验证，以确保其符合 JVM 规范和安全性要求。这包括对类的字节码验证、符号引用验证、以及其他规范约束的检查。验证通常在加载之后、解析之前执行。</p></li><li><p>准备（Preparation）： 在准备阶段，JVM 为类的静态变量分配内存并进行初始化。这些变量会被赋予默认初始值，通常是零值，而不是它们在类中指定的初始值。这是为了确保类的静态变量在使用之前已经被分配内存，以免出现未初始化的情况。</p></li><li><p>解析（Resolution）： 解析阶段是将类、接口、字段和方法的符号引用解析为直接引用的过程。符号引用是一种符号化的引用，而直接引用是直接指向内存地址的引用。解析的目标是将类和成员的符号引用映射到具体的内存地址，以便在运行时能够正确调用类的方法和访问其字段。</p></li><li><p>初始化（Initialization）： 初始化阶段是类加载的最后一步，也是在首次实际使用类时发生的。在初始化阶段，JVM 会执行类的初始化代码，包括<strong>静态变量赋值和静态初始化块</strong>。这确保了类的静态成员在使用之前已经被正确初始化。</p></li></ol><p>需要注意的是，初始化阶段可能被延迟到首次实际使用类的时候，也可以通过使用 <code>Class.forName()</code> 方法的 <code>initialize</code> 参数或静态变量的引用来触发初始化。这种延迟初始化的机制可以提高应用程序的性能，因为它只会初始化实际需要使用的类。</p><h2 id="q-a" tabindex="-1"><a class="header-anchor" href="#q-a" aria-hidden="true">#</a> Q&amp;A</h2><h3 id="有可能类会先被加载-但没有初始化-这是什么情况下会发生" tabindex="-1"><a class="header-anchor" href="#有可能类会先被加载-但没有初始化-这是什么情况下会发生" aria-hidden="true">#</a> 有可能类会先被加载，但没有初始化，这是什么情况下会发生？</h3><p>是的，Java 中存在一种情况，即类可能会先被加载，但不会立即初始化。这是因为 Java 采用了一种延迟初始化的策略，只有在真正需要使用类时才会进行初始化。以下是可能发生这种情况的情形：</p><ol><li><p><strong>访问静态常量</strong>：当你访问一个类的静态常量（<code>static final</code> 字段）时，该类会被加载，但不会初始化。这是因为静态常量在编译时已经被赋予了初始值，不需要在运行时再进行初始化。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MY_CONSTANT</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当你访问 <code>MyClass.MY_CONSTANT</code> 时，<code>MyClass</code> 会被加载但不会初始化。</p></li><li><p><strong>通过类名访问静态字段</strong>：当你通过类名访问一个类的静态字段（不是通过实例对象）时，类会被加载，但不会立即初始化。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> myStaticField <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当你使用 <code>MyClass.myStaticField</code> 时，<code>MyClass</code> 会被加载但不会初始化。</p></li><li><p><strong>Class.forName() 方法</strong>：如果使用反射的 <code>Class.forName()</code> 方法来加载一个类时，类会被加载但不会立即初始化。你可以选择是否在加载后初始化该类。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.example.MyClass&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>默认情况下，不会立即初始化，但你可以通过传递 <code>true</code> 作为第二个参数来强制初始化：<code>Class.forName(&quot;com.example.MyClass&quot;, true);</code></p></li></ol><p>这些情况下，类会被加载以便访问静态成员，但初始化是在首次使用类的静态成员或创建类的实例时才会发生。这种延迟初始化的策略有助于提高性能，因为不是所有的类都需要在应用程序启动时立即初始化。</p>`,12),t=[l];function i(c,p){return s(),n("div",null,t)}const u=a(o,[["render",i],["__file","类加载.html.vue"]]);export{u as default};
