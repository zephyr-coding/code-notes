import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as t,o,c as i,a as e,b as s,d as l,f as c}from"./app-kEfL-mm4.js";const r={},d=e("p",null,"集合笔记 xxxsf 不知道啊。今天多少度大概 3% 个吧！硬盘容量 300 GB 根本不够用。",-1),u=e("p",null,"我家的光纖入屋寬頻有 10 Gbps，SSD 一共有 20 TB。",-1),p=e("h2",{id:"标题呀",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#标题呀","aria-hidden":"true"},"#"),s(" 标题呀")],-1),_=e("p",null,"今天一共有多少个 Java 选手？我今天准备了 30 个好吃的东西。硬盘容量仅仅有 30 TB 所以不够用。我需要 30 mb 的资源你有吗。今天的温度是 19% 呀。新 MacBook Pro 有 15% 的 CPU 性能提升。角度為 90° 的角，就是直角。引号「可以的」。我喜欢数字 7。我喜欢数字 8。",-1),h=e("p",null,"期望有 GMV 7 万。我有个 7 MB 不行的磁盘，你看看～。夹角大小是 8° 行吗？",-1),m=e("p",null,"这能行吗 [[这是一个数学公式english]] 我不知道 这不一定好用啊 [[一片树林]] 对不？",-1),f=e("h2",{id:"标题哦",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#标题哦","aria-hidden":"true"},"#"),s(" 标题哦")],-1),v={href:"https://quartz.jzhao.xyz",target:"_blank",rel:"noopener noreferrer"},k=c(`<p>看看代码 <code>ji</code> 可以吗</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token function">sout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> pulic
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>sdf</li><li>Sdfsd</li><li>Elast</li></ul><p>不明白咋回事。。</p><ul><li>sdfds</li><li>dsfsdaf</li></ul><p>现在开始换行</p><ul><li>[ ] Item 1</li><li>[x] Item 2 <ul><li>[ ] Item 3</li></ul></li></ul><p>现在开始换行</p><p>不好使</p><p>现在开始换行</p><p>说得通俗些，这个条件声明工作内存中必须存在一个 PermissionCheck 对象，它具有与 &quot;customer&quot; 相当的 name 属性，以及与 &quot;delete&quot; 相当的 action 属性。什么是工作内存？它是个会话范围的对象，包含规则引擎进行有关许可检查决策时所需的上下文信息。每次调用 hasPermission() 方法时，一个临时的 PermissionCheck 对象或者 Fact 就被断言到工作内存中。这个 PermissionCheck 正好对应于正被检查的许可，因此，例如如果调用 hasPermission(&quot;account&quot;, &quot;create&quot;, null)，那么带有相当于 &quot;account&quot; 的 name 和相当于 &quot;create&quot; 的 action 的 PermissionCheck 对象，就将在许可检查持续期间被断言到工作内存。</p><p>工作内存中还有什么其它的东西？除了在许可检查期间断言的短期临时 fact 被插入之外，工作内存中还有一些长期的对象，在用户验证的整个持续期间都保留在那。这些包括作为验证过程一部分而创建的任何 java.security.Principal 对象，还包括用户所属角色中的每一个角色的 org.jboss.seam.security.Role。通过调用 ((RuleBasedIdentity) RuleBasedIdentity.instance()).getSecurityContext().insert()，也可能断言额外的长期 fact 到工作内存中，把对象当作参数传递。</p><p>回到我们的简单例子上来，也会注意到我们 LHS 的第一行加上了 c: 的前缀。这是个变量绑定，用来指回到符合条件的对象。移到 LHS 的第二行，会看到：</p>`,14);function q(x,b){const a=t("ExternalLinkIcon");return o(),i("div",null,[d,u,p,_,h,m,f,e("p",null,[s("这不一定好用啊 "),e("a",v,[s("官方文档"),l(a)]),s(" 知道。")]),k])}const P=n(r,[["render",q],["__file","新的笔记.html.vue"]]);export{P as default};
